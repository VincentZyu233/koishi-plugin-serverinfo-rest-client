import { Context, h } from 'koishi'
import { Config } from '../config'
import {
  ApiClient,
  resolveOutputModes,
  getTypstRenderer,
  buildTypstTheme,
  escapeTypstText,
} from '../index'
import path from 'node:path'
import fs from 'node:fs'

const pkg = JSON.parse(
  fs.readFileSync(path.resolve(__dirname, '../package.json'), 'utf-8')
)
const CLIENT_VERSION = pkg.version

interface StatusResponse {
  status: string
  plugin: string
  version: string
  playerCount: number
  bdsVersion: string
  protocolVersion: number
}

function formatTextOutput(data: StatusResponse, label: string): string {
  const statusEmoji = data.status === 'online' ? 'ğŸŸ¢' : 'ğŸ”´'
  return `${label} ğŸ“Š æœåŠ¡å™¨çŠ¶æ€

${statusEmoji} çŠ¶æ€: ${data.status}
ğŸ”Œ æœåŠ¡ç«¯æ’ä»¶: ${data.plugin} v${data.version}
ğŸ¤– Bot å®¢æˆ·ç«¯: v${CLIENT_VERSION}
ğŸ‘¥ åœ¨çº¿ç©å®¶: ${data.playerCount}
ğŸ® BDS ç‰ˆæœ¬: ${data.bdsVersion}
ğŸ“¡ åè®®ç‰ˆæœ¬: ${data.protocolVersion}`
}

function generateTypstCode(data: StatusResponse, theme: ReturnType<typeof buildTypstTheme>, label: string): string {
  const timestamp = new Date().toLocaleString('zh-CN')
  const statusEmoji = data.status === 'online' ? 'ğŸŸ¢' : 'ğŸ”´'

  return `#set page(
  width: 400pt,
  height: auto,
  margin: (x: 14pt, y: 14pt),
  fill: ${theme.pageBg}
)

#set text(
  font: ("${theme.fontFamily}", "Noto Sans CJK SC", "Microsoft YaHei"),
  size: 11pt,
  fill: ${theme.textColor},
  lang: "zh"
)

#align(center)[
  #block(
    fill: ${theme.headerFill},
    stroke: 2pt + ${theme.headerStroke},
    radius: 6pt,
    inset: 10pt,
    width: 100%
  )[
    #text(size: 16pt, weight: "bold", fill: ${theme.headerText})[
      ${escapeTypstText(label)} ğŸ“Š æœåŠ¡å™¨çŠ¶æ€
    ]
  ]
]

#v(8pt)

#block(
  fill: ${theme.panelFill},
  stroke: 1pt + ${theme.panelStroke},
  radius: 4pt,
  inset: 12pt,
  width: 100%
)[
  #table(
    columns: (auto, 1fr),
    stroke: none,
    row-gutter: 8pt,
    align: (left, horizon),
    
    text(weight: "bold", fill: ${theme.sectionTitle})[${statusEmoji} çŠ¶æ€],
    [${escapeTypstText(data.status)}],
    
    text(weight: "bold", fill: ${theme.sectionTitle})[ğŸ”Œ æœåŠ¡ç«¯æ’ä»¶],
    [${escapeTypstText(data.plugin)} v${escapeTypstText(data.version)}],
    
    text(weight: "bold", fill: ${theme.sectionTitle})[ğŸ¤– Bot å®¢æˆ·ç«¯],
    [v${escapeTypstText(CLIENT_VERSION)}],
    
    text(weight: "bold", fill: ${theme.sectionTitle})[ğŸ‘¥ åœ¨çº¿ç©å®¶],
    [${data.playerCount}],
    
    text(weight: "bold", fill: ${theme.sectionTitle})[ğŸ® BDS ç‰ˆæœ¬],
    [${escapeTypstText(data.bdsVersion)}],
    
    text(weight: "bold", fill: ${theme.sectionTitle})[ğŸ“¡ åè®®ç‰ˆæœ¬],
    [${data.protocolVersion}],
  )
]

#v(8pt)

#align(center)[
  #text(size: 8pt, fill: ${theme.statsText})[
    Generated by serverinfo-rest-client Â· ${escapeTypstText(timestamp)}
  ]
]
`
}

export function registerStatusCommand(
  ctx: Context,
  cfg: Config,
  apiClient: ApiClient,
  logger: any,
  prefix: string,
  label: string
) {
  ctx.command(`${prefix}.status`, 'æœåŠ¡å™¨çŠ¶æ€')
    .option('mode', '-m <mode:string> è¾“å‡ºæ¨¡å¼ (text/image)')
    .action(async ({ session, options }) => {
      try {
        const data = await apiClient.get<StatusResponse>('/status')
        const modes = resolveOutputModes(options.mode, cfg)

        const results: h[] = []

        for (const mode of modes) {
          if (mode === 'text') {
            results.push(h.text(formatTextOutput(data, label)))
          } else if (mode === 'typst-image') {
            try {
              const renderer = await getTypstRenderer(ctx, cfg, logger)
              const theme = buildTypstTheme(cfg)
              const typstCode = generateTypstCode(data, theme, label)
              const pngBuffer = await renderer.toPng(typstCode, cfg.typstRenderScale)
              results.push(h.image(pngBuffer, 'image/png'))
            } catch (err) {
              logger.warn(`Typst æ¸²æŸ“å¤±è´¥: ${err}`)
              results.push(h.text(`[Typst æ¸²æŸ“å¤±è´¥: ${err.message}]`))
            }
          }
        }

        if (cfg.quoteCommandReplies && session.messageId) {
          return h('', [h.quote(session.messageId), ...results])
        }
        return results
      } catch (error) {
        logger.error(`è·å–æœåŠ¡å™¨çŠ¶æ€å¤±è´¥: ${error}`)
        return `âŒ è·å–æœåŠ¡å™¨çŠ¶æ€å¤±è´¥: ${error.message}`
      }
    })
}
